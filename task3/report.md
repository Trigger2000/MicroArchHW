1. Объясните смысл и напишите формулы для следующих метрик производительности процессора IPC, CPI, Performance, Dynamic Power

* IPC (instructions per cycle) - среднее количество инструкций, исполняемых процессором за 1 такт
$$ IPC = \frac{N}{M}, N - количество\ инструкций, M - количество\ тактов $$

* CPI (cycles per instruction) - среднее количество тактов, затрачиваемое процессором на исполнение одной инстркции
$$ CPI = \frac{1}{IPC} $$

* Performance - скорость исполнения программы. Одна из основных метрик, наряду с Power и Cost, оцениваемых при проектировании процессора.
$$ Perf = \frac{1}{T_{total}} = \frac{1}{N_{cycles} T_{per\ cycle}} = \frac{1}{N_{instr} T_{per\ cycle} CPI} = \frac{ f \cdot IPC }{N_{instr}} $$

* Dynamic Power, динамическая потребляемая мощность - затраты энергии на перезарядку паразитных емкостей при переключении транзистров в процессоре.
$$ DynPower = \frac{1}{2} \cdot C_{eff} \cdot V_{dd}^2 \cdot a \cdot f, а\ - \ частота\ переключения\ транзистора $$

2. Что такое суперскалярный (superscalar) процессор?

    Суперскалярный процессор - процессор, способный обрабатывать более одной инструкции за такт, используя дополнительные вычислительные ресурсы (например, АЛУ, векторные или VLIW инструкции)

3. Какие типы зависимостей по данным существуют? Приведите примеры аппаратных оптимизаций, которые позволяют сократить связанные задержки или разрешить каждый тип зависимостей.

* False dependencies:

    * Write-After-Write
    * Write-After-Read

    Данные зависимости не являются настоящими зависимостями, так как поздней инструкции в действительности не нужны данные с ранней. Единственный вопрос, который здесь возникает - на какой регистр положить данные, чтобы не было пересечений между инструкциями. Если бы процессор использовал только архитектурные регистры, определяемые ISA, то такие конфликты были бы частыми. Но физичеки процессор имеет бОльшее количество регистров, чем определено в ISA. Поэтому для уменьшения количества False dependencies при исполнении программы необходимо провести register renaming. Маппинг между архитектурными и физическими регистрами поддерживается с помощью Register Aliases Table (RAT). Альтернативным способом борьбы с False dependency является разбиение операций store на вычисление адреса (STA) и вычисление данных (STD), о чем будет сказано в вопросе 4.

* True dependency
    * Read-After-Write

    Store никогда не может быть спекулятивно исполнен и переупорядочить исполнение store инструкций нельзя. Но можно попробовать сделать store forwarding - пробросить результат выполнения store инструкции напрямую в load инструкцию, минуя кэши и память. У такого подхода есть, очевидно, ограничения: адреса и размеры store load инструкций должны совпадать. Пересечения по адресам помогает понять Load and Store Buffer.

4. С какой целью инструкцию Store разделяют на микро-операции STA (Store address calculation) и STD (Store data calculation) ?

    Мы хотим сделать так, чтобы зависимостей между load и store инструкциями было как можно меньше. Между load и store инстркуциями есть зависимость, если адреса, по которым происходит чтение/запись, пересекаются. Но чтобы выяснить наличие пересечения адресов, надо знать сами адреса. В обычной реализации адрес, по которому происходит store, не будет известен, пока не будут готовы данные для записи. Хотелось бы определять адрес store по возможности раньше, чем будут готовы сами даные, чтобы избежать лишних зависимостей между load/store инсрукциями. Для этого store разделяется на инструкцию вычисления адреса STA (Store address calculation) и на инструкцию вычисления данных STD (Store data calculation).

5. Объясните назначение и функции следующих аппаратных структур: ROB, Scheduler Queue (Issue Queue, Reservation Station), RAT, PRF, Load Buffer, Store Buffer

* ROB (reorder buffer). При out of order исполнении инструкции исполняются в перемешку. Но при этом порядок исполнения инструкций важен, так как необходимо поддерживать архитектурное состояние на случай возникновения, например, исключений, прерываний или чего-нибудь еще. Для поддержания спекулятивного и архитектурного состояния существует ROB. В нем инструкция записывается и хранится в обычном порядке, но покидает ROB и обновляет архитектурное состоние только в случае, когда эта инструкция самая старая и была исполнена.

* SQ (Scheduler Queue). По ROB'у необходимо производить 2 довольно сложных обхода: при аллокации регистров для определения инструкций, которые производят результат для использования в других инстукциях; при определение готовых инструкций для того, чтобы отправить их на исполнение. Чем больше ROB, тем дольше поиск. На самом деле, достаточно проверять только неготовые инструкции, количество которых намного меньше, чем весь ROB. Для неготовых инструкций можно завести отдельную очередь, Scheduler Queue, по которой будут производится оба вышеупомянутых обхода. А ROB будет использован только для поддержания состояния при выходе инструкции из ROB.

* RAT (register alias table). Таблица соответствия физических и архитектурных регистров при register renaming.

* PRF (physical register file). Регистровый файл, содержащий все физические регистры процессора. Используется при register renaming.

* Load Buffer, Store Buffer. Чтобы найти зависимости между load и store, необходимо вычислить адреса, с которыми они работают, для чего нужно обойти весь ROB, чтобы в принципе найти load/store инструкции. Как и в случае Scheduler Queue, можно сделать отдельный буффер, в котором будем хранить только load/store инструкции и искать зависимости между ними, обходя этот буффер, а не весь ROB.

6. Пусть каждая 5ая инструкция в процессоре это Branch. Предсказатель переходов имеет точность 90%. Оцените, ROB какого максимального размера имеет смысл для такого процессора.

    Хотим избежать ситуации миспредикта бранчей, поскольку при этом происходит удаление всех последующих инструкций из ROB, что делает ROB неэффективным. Оценим вероятность $P_N$ того, что для ROB размером $N$ все инструкции будут выполнены. Если каждая пятая инструкция - это бранч, то $P_{br} = 0.2$, а $P_{predict} = 0.9$ по условию. Если всего инструкций в ROB $N$, то бранчей из них $$N_{br} = N \cdot P_{br}$$ Вероятность того, что все бранчи будут предсказаны правильно $$ P_N = P_{predict}^{N_{br}} = P_{predict}^{N \cdot P_{br}}$$ Отсюда находим $$ N = \frac{\ln P_N}{P_{br} \cdot \ln P_{predict}} $$ Если взять $P_N = 0.95$, то $N \approx 2.43$. Делать ROB настолько маленьким скорее всего даже не имеет смысла.

7. Что такое Memory Disambiguation?

    Общее название техник, применяемых в out of order процессорах для уменьшения количества зависимостей по данным и увеличения ILP. К таким техникам относятся вышеупомянутые register renaming, store forwarding, Load Buffer, Store Buffer и др.

8. В чем заключается проблема со спекулятивным исполнением Store инструкций?

    Store инструкции невозможно спекулятивно исполнять, так как они напрямую влияют на архитектурное состояние процессора, которое невозможно восстановить в случае неправильного спекулятивного исполнения store инструкции.

9. Что такое Store forwarding и Load speculation в OOO процессоре?

    Store forwarding описан в пункте 3 про True dependency.

    Load speculation - набор техник, позволяющий load инструкциям не ждать исполнения всех предыдущих store инструкций, а исполняться спекулятивно. По информации из [article](https://cseweb.ucsd.edu/~calder/papers/JILP-00-LoadSpec.pdf) существует 4 техники:

    * Dependence Prediction - позволяет предсказать, от какого store зависит исследуемый load, либо не зависит воообще;
    * Address Prediction - предсказание адреса, по которому будет произведен load;
    * Value Prediction - предсказание данных, которые будут извлечены из памяти при выполнении load инструкции;
    * Memory Renaming - предсказывает зависимости между laod и store и пробрасывает значения непосредственно из store в load.

10. Что такое Simultaneous Multithreading?

    Simultaneous Multithreading - исполнение нескольких логических потоков на одном физическом ядре, которое достигается путем разделения и более эффективного использования ресурсов одного физического ядра. Каждый логический процессор поддерживает своё собственное архитектурное состояние, а каждая стадия в пайплайне занята всегда занята одним из потоков. Ресурсы могут делиться между логическими 3 способами: replicated, partitioned или shared. При SMT подходе общая производительность процессора может возрасти при условии того, что производительность на отдельном потоке может ухудшиться.